var debug = require('debug')('nodemon:run');
const statSync = require('fs').statSync;
var utils = require('../utils');
var bus = utils.bus;
var childProcess = require('child_process');
var spawn = childProcess.spawn;
var exec = childProcess.exec;
var execSync = childProcess.execSync;
var fork = childProcess.fork;
var watch = require('./watch').watch;
var config = require('../config');
var child = null; 
var killedAfterChange = false;
var noop = () => {};
var restart = null;
var psTree = require('pstree.remy');
var path = require('path');
var signals = require('./signals');
const undefsafe = require('undefsafe');
const osRelease = parseInt(require('os').release().split('.')[0], 10);
function run(options) {
  var cmd = config.command.raw;
  /*jshint validthis:true*/
  restart = run.bind(this, options);
  run.restart = restart;
  run.options = options;
  var runCmd = !options.runOnChangeOnly || config.lastStarted !== 0;
  if (runCmd) {
    utils.log.status('starting `' + config.command.string + '`');
  } else {
    debug('start watch on: %s', config.options.watch);
    if (config.options.watch !== false) {
      watch();
      return;
    }
  }
  config.lastStarted = Date.now();
  var stdio = ['pipe', 'pipe', 'pipe'];
  if (config.options.stdout) {
    stdio = ['pipe', process.stdout, process.stderr];
  }
  if (config.options.stdin === false) {
    stdio = [process.stdin, process.stdout, process.stderr];
  }
  var sh = 'sh';
  var shFlag = '-c';
  const binPath = process.cwd() + '/node_modules/.bin';
  const spawnOptions = {
    env: Object.assign({}, options.execOptions.env, process.env, {
      PATH:
        binPath +
        path.delimiter +
        (undefsafe(options, '.execOptions.env.PATH') || process.env.PATH),
    }),
    stdio: stdio,
  };
  var executable = cmd.executable;
  if (utils.isWindows) {
    if (executable.indexOf('/') !== -1) {
      executable = executable
        .split(' ')
        .map((e, i) => {
          if (i === 0) {
            return path.normalize(e);
          }
          return e;
        })
        .join(' ');
    }
    sh = process.env.comspec || 'cmd';
    shFlag = '/d /s /c';
    spawnOptions.windowsVerbatimArguments = true;
    spawnOptions.windowsHide = true;
  }
  var args = runCmd ? utils.stringify(executable, cmd.args) : ':';
  var spawnArgs = [sh, [shFlag, args], spawnOptions];
  const firstArg = cmd.args[0] || '';
  var inBinPath = false;
  try {
    inBinPath = statSync(`${binPath}/${executable}`).isFile();
  } catch (e) {}
  const hasStdio = utils.satisfies('>= 6.4.0 || < 5');
  const shouldFork =
    !config.options.spawn &&
    !inBinPath &&
    !(firstArg.indexOf('-') === 0) && 
    firstArg !== 'inspect' && 
    executable === 'node' && 
    utils.version.major > 4; 
  if (shouldFork) {
    var forkArgs = cmd.args.slice(1);
    var env = utils.merge(options.execOptions.env, process.env);
    stdio.push('ipc');
    const forkOptions = {
      env: env,
      stdio: stdio,
      silent: !hasStdio,
    };
    if (utils.isWindows) {
      forkOptions.windowsHide = true;
    }
    child = fork(options.execOptions.script, forkArgs, forkOptions);
    utils.log.detail('forking');
    debug('fork', sh, shFlag, args);
  } else {
    utils.log.detail('spawning');
    child = spawn.apply(null, spawnArgs);
    debug('spawn', sh, shFlag, args);
  }
  if (config.required) {
    var emit = {
      stdout: function (data) {
        bus.emit('stdout', data);
      },
      stderr: function (data) {
        bus.emit('stderr', data);
      },
    };
    if (config.options.stdout) {
      child.on('stdout', emit.stdout).on('stderr', emit.stderr);
    } else {
      child.stdout.on('data', emit.stdout);
      child.stderr.on('data', emit.stderr);
      bus.stdout = child.stdout;
      bus.stderr = child.stderr;
    }
    if (shouldFork) {
      child.on('message', function (message, sendHandle) {
        bus.emit('message', message, sendHandle);
      });
    }
  }
  bus.emit('start');
  utils.log.detail('child pid: ' + child.pid);
  child.on('error', function (error) {
    bus.emit('error', error);
    if (error.code === 'ENOENT') {
      utils.log.error('unable to run executable: "' + cmd.executable + '"');
      process.exit(1);
    } else {
      utils.log.error('failed to start child process: ' + error.code);
      throw error;
    }
  });
  child.on('exit', function (code, signal) {
    if (child && child.stdin) {
      process.stdin.unpipe(child.stdin);
    }
    if (code === 127) {
      utils.log.error(
        'failed to start process, "' + cmd.executable + '" exec not found'
      );
      bus.emit('error', code);
      process.exit();
    }
    if (code === 2 && Date.now() < config.lastStarted + 500) {
      utils.log.error('process failed, unhandled exit code (2)');
      utils.log.error('');
      utils.log.error('Either the command has a syntax error,');
      utils.log.error('or it is exiting with reserved code 2.');
      utils.log.error('');
      utils.log.error('To keep nodemon running even after a code 2,');
      utils.log.error('add this to the end of your command: || exit 1');
      utils.log.error('');
      utils.log.error('Read more here: https:
      utils.log.error('');
      utils.log.error('nodemon will stop now so that you can fix the command.');
      utils.log.error('');
      bus.emit('error', code);
      process.exit();
    }
    if (killedAfterChange) {
      killedAfterChange = false;
      signal = config.signal;
    }
    if (utils.isWindows && signal === 'SIGTERM') {
      signal = config.signal;
    }
    if (signal === config.signal || code === 0) {
      debug('bus.emit(exit) via ' + config.signal);
      bus.emit('exit', signal);
      if (signal === config.signal) {
        return restart();
      }
      if (code === 0) {
        if (runCmd) {
          utils.log.status('clean exit - waiting for changes before restart');
        }
        child = null;
      }
    } else {
      bus.emit('crash');
      if (options.exitcrash) {
        options.exitCrash = true;
        delete options.exitcrash;
      }
      if (options.exitCrash) {
        utils.log.fail('app crashed');
        if (!config.required) {
          process.exit(1);
        }
      } else {
        utils.log.fail(
          'app crashed - waiting for file changes before' + ' starting...'
        );
        child = null;
      }
    }
    if (config.options.restartable) {
      process.stdin.resume();
    }
  });
  if (options.stdin) {
    process.stdin.resume();
    if (hasStdio) {
      child.stdin.on('error', () => {});
      process.stdin.pipe(child.stdin);
    } else {
      if (child.stdout) {
        child.stdout.pipe(process.stdout);
      } else {
        utils.log.error(
          'running an unsupported version of node ' + process.version
        );
        utils.log.error(
          'nodemon may not work as expected - ' +
            'please consider upgrading to LTS'
        );
      }
    }
    bus.once('exit', function () {
      if (child && process.stdin.unpipe) {
        process.stdin.unpipe(child.stdin);
      }
    });
  }
  debug('start watch on: %s', config.options.watch);
  if (config.options.watch !== false) {
    watch();
  }
}
function waitForSubProcesses(pid, callback) {
  debug('checking ps tree for pids of ' + pid);
  psTree(pid, (err, pids) => {
    if (!pids.length) {
      return callback();
    }
    utils.log.status(
      `still waiting for ${pids.length} sub-process${
        pids.length > 2 ? 'es' : ''
      } to finish...`
    );
    setTimeout(() => waitForSubProcesses(pid, callback), 1000);
  });
}
function kill(child, signal, callback) {
  if (!callback) {
    callback = noop;
  }
  if (utils.isWindows) {
    const taskKill = () => {
      try {
        exec('taskkill /pid ' + child.pid + ' /T /F');
      } catch (e) {
        utils.log.error('Could not shutdown sub process cleanly');
      }
    };
    if (
      signal === 'SIGKILL' ||
      osRelease < 10 ||
      signal === 'SIGUSR2' ||
      signal === 'SIGUSR1'
    ) {
      debug('terminating process group by force: %s', child.pid);
      taskKill();
      callback();
      return;
    }
    try {
      const resultBuffer = execSync(
        `wmic process where (ParentProcessId=${child.pid}) get ProcessId 2> nul`
      );
      const result = resultBuffer.toString().match(/^[0-9]+/m);
      const processId = Array.isArray(result) ? result[0] : child.pid;
      debug('sending kill signal SIGINT to process: %s', processId);
      const windowsKill = path.normalize(
        `${__dirname}/../../bin/windows-kill.exe`
      );
      execSync(
        `start "windows-kill" /min /wait "${windowsKill}" -SIGINT ${processId}`
      );
    } catch (e) {
      taskKill();
    }
    callback();
  } else {
    let sig = signal.replace('SIG', '');
    psTree(child.pid, function (err, pids) {
      if (!psTree.hasPS) {
        sig = signals[signal];
      }
      debug('sending kill signal to ' + pids.join(', '));
      child.kill(signal);
      pids.sort().forEach((pid) => exec(`kill -${sig} ${pid}`, noop));
      waitForSubProcesses(child.pid, () => {
        exec(`kill -${sig} ${child.pid}`, callback);
      });
    });
  }
}
run.kill = function (noRestart, callback) {
  if (typeof noRestart === 'function') {
    callback = noRestart;
    noRestart = false;
  }
  if (!callback) {
    callback = noop;
  }
  if (child !== null) {
    if (run.options.stdin) {
      process.stdin.unpipe(child.stdin);
    }
    if (!noRestart) {
      killedAfterChange = true;
    }
    /* Now kill the entire subtree of processes belonging to nodemon */
    var oldPid = child.pid;
    if (child) {
      kill(child, config.signal, function () {
        if (child && run.options.stdin && child.stdin && oldPid === child.pid) {
          child.stdin.end();
        }
        callback();
      });
    }
  } else if (!noRestart) {
    bus.once('start', callback);
    run.restart();
  } else {
    callback();
  }
};
run.restart = noop;
bus.on('quit', function onQuit(code) {
  if (code === undefined) {
    code = 0;
  }
  var exitTimer = null;
  var exit = function () {
    clearTimeout(exitTimer);
    exit = noop; 
    child = null;
    if (!config.required) {
      bus.listeners('quit').forEach(function (listener) {
        if (listener !== onQuit) {
          listener();
        }
      });
      process.exit(code);
    } else {
      bus.emit('exit');
    }
  };
  if (config.run === false) {
    return exit();
  }
  config.run = false;
  if (child) {
    exitTimer = setTimeout(exit, 10 * 1000);
    child.removeAllListeners('exit');
    child.once('exit', exit);
    kill(child, 'SIGINT');
  } else {
    exit();
  }
});
bus.on('restart', function () {
  run.kill();
});
process.on('exit', function () {
  utils.log.detail('exiting');
  if (child) {
    child.kill();
  }
});
if (!utils.isWindows) {
  bus.once('boot', () => {
    process.once('SIGINT', () => bus.emit('quit', 130));
    process.once('SIGTERM', () => {
      bus.emit('quit', 143);
      if (child) {
        child.kill('SIGTERM');
      }
    });
  });
}
module.exports = run;